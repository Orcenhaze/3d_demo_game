#include "game.h"

#include "mesh.cpp"
#include "terrain.cpp"
#include "collision.cpp"
#include "entity.cpp"
#include "render.cpp"

#include "lexer.cpp"
#include "parser.cpp"
#include "editor.cpp"

GLOBAL b32 global_game_initialized;

FUNCTION void load_assets(Game_State *game)
{
    Arena_List *arena_list = &game->arena_list;
    
    {
        STRING_TEMPF(asset_full_path, "%s%s", global_data_directory_full_path, "texture_data/*.jpg");
        load_textures_into_global_hash_table(arena_list, asset_full_path);
    }
    
    {
        STRING_TEMPF(asset_full_path, "%s%s", global_data_directory_full_path, "texture_data/*.png");
        load_textures_into_global_hash_table(arena_list, asset_full_path);
    }
    
    {
        STRING_TEMPF(asset_full_path, "%s%s", global_data_directory_full_path, "mesh_data/*.mesh");
        load_meshes_into_global_hash_table(arena_list, asset_full_path);
    }
}

FUNCTION void load_level(Game_State *game, String level_full_path)
{
    //
    // Parse level.
    //
    parse_level(game, level_full_path);
    
    //
    // Terrain.
    //
    // @Hardcode: Should specify these things in the level format. 
    Vector3 ter_p = make_vector3(0.0f, -9.0f, 0.0f);
    Vector3 ter_s = make_vector3(5000.0f, 150.0f, 5000.0f);
    f32 uv_scale  = 250.0f;
    make_terrain(&game->arena_list, &game->terrain, 
                 ter_p, ter_s, uv_scale, 1024);
    //
    // Skybox.
    //
    load_cube_map(&game->skybox);
    
    //
    // Audio.
    //
#if !DEBUG_BUILD
    STRING_TEMPF(audio_full_path, "%ssounds/%S", global_data_directory_full_path, game->music_file_name);
    platform_api->audio_init_and_start(audio_full_path);
#endif
}

FUNCTION void save_level(Game_State *game, String destination_full_path)
{
    ASSERT(destination_full_path.data);
    
    String_Builder builder = make_string_builder(&game->arena_list.temp_arena);
    String_Builder *sb     = &builder;
    
    append(sb, 
           "//\n"
           "// THIS FILE IS AUTOMATICALLY GENERATED.\n"
           "//\n\n");
    
    appendf(sb, "terrain_height_map \"%S\"\n", 
            game->terrain.height_map?
            get_base_name(game->terrain.height_map->full_path)  : STRING_ZERO);
    appendf(sb, "terrain_diffuse_map \"%S\"\n", 
            game->terrain.diffuse_map?
            get_base_name(game->terrain.diffuse_map->full_path) : STRING_ZERO);
    appendf(sb, "skybox_cube_map \"%S\"\n", get_base_name(game->skybox.directory_full_path));
    appendf(sb, "music \"%S\"\n\n",         game->music_file_name);
    
    u32 entity_count = 1;
    for(Entity_Iterator it = iterate_all_entities(game);
        it.entity;
        advance(&it))
    {
        if(is_cleared(it.entity, EntityFlags_VISIBLE)) continue;
        entity_count++;
    }
    
    appendf(sb, "entity_count %u\n\n", entity_count);
    
    append(sb, 
           "//\n"
           "//\n"
           "// INVALID ENTITY.\n"
           "//\n"
           "//\n\n");
    
    for(Entity_Iterator it = iterate_all_entities(game);
        it.entity;
        advance(&it))
    {
        Entity *e = it.entity;
        if(is_cleared(e, EntityFlags_VISIBLE)) continue;
        
        Vector3 axis = quaternion_get_axis(e->orientation);
        f32 angle    = to_degrees(quaternion_get_angle(e->orientation));
        
        appendf(sb, "type %d\n", e->type);
        appendf(sb, "pos %f %f %f\n", e->position.x, e->position.y, e->position.z);
        appendf(sb, "ori %f %f %f %f\n", axis.x, axis.y, axis.z, angle);
        appendf(sb, "scale %f %f %f\n", e->scale.x, e->scale.y, e->scale.z);
        appendf(sb, "facing %f %f %f\n", e->facing_direction.x, e->facing_direction.y, e->facing_direction.z);
        
        if(is_set(e, EntityFlags_EMISSIVE))
        {
            appendf(sb, "light_color %f %f %f\n", e->light_color.x, e->light_color.y, e->light_color.z);
        }
        
        if((e->type == EntityType_GHOST) ||
           (e->type == EntityType_SKULL))
        {
            appendf(sb, "move_area_scale %f %f %f\n", e->move_area_scale.x, e->move_area_scale.y, e->move_area_scale.z);
        }
        
        appendf(sb, "flags %u\n", e->flags);
        appendf(sb, "mesh \"%S\"\n", e->mesh->name);
        
        append(sb, "\n");
    }
    
    if(platform_api->write_entire_file(destination_full_path, to_string(sb)))
    {
        PRINT("Game saved! Destination: %S\n", destination_full_path);
    }
    else
    {
        PRINT("Error: couldn't save game.\n");
    }
    
    clear_arena(&game->arena_list.temp_arena);
}

FUNCTION void cache_light_entities(Game_State *game)
{
    for(Entity_Iterator it = iterate_all_entities(game);
        it.entity;
        advance(&it))
    {
        Entity *e = it.entity;
        
        if((is_set(e, EntityFlags_EMISSIVE)) &&
           (game->num_point_light_entities < MAX_POINT_LIGHTS))
        {
            game->point_light_entities[game->num_point_light_entities++] = e;
        }
    }
}

extern "C" void game_init(Game_Memory *memory)
{
    global_data_directory_full_path = memory->data_directory_full_path;
    platform_api                    = &memory->platform_api;
    extensions                      = &memory->gl_extensions;
    
    // Initializing OpenGL.
    opengl_init(memory);
    
    // Initializing memory arenas.
    Game_State *game = (Game_State *) memory->permanent_storage;
    memory_arena_init(&game->arena_list.permanent_arena, 
                      memory->permanent_storage_size - sizeof(Game_State),
                      (u8*)memory->permanent_storage + sizeof(Game_State));
    sub_arena(&game->arena_list.temp_arena,  &game->arena_list.permanent_arena, MEGABYTES(32));
    sub_arena(&game->arena_list.level_arena, &game->arena_list.permanent_arena, MEGABYTES(256));
    
    // Loading assets.
    load_assets(game);
    
    // Load local.variables.
    game->current_level_full_path = push_stringf(&game->arena_list.permanent_arena, 
                                                 "%slevel_data/%s", 
                                                 global_data_directory_full_path, "main.level");
    
    
    // Load level data.
    load_level(game, game->current_level_full_path);
    
    // Pre-store light entities.
    cache_light_entities(game);
    
    // Camera initialization.
    game->offset_camera           = make_vector3(0.0f, 3.0f, 8.0f);
    game->debug_camera.position   = game->offset_camera;
    game->debug_camera.front      = VECTOR3_F;
    game->debug_camera.up         = VECTOR3_U;
    game->game_camera.position    = game->offset_camera;
    game->invert_camera           = false;
    
    // Selected entity initialization.
    game->selected_entity.sort_index = MAX_F32;
    game->selected_entity.entity     = game->level_entities + 0;
}

FUNCTION void change_level(Game_State *game, String level_full_path)
{
    if(string_empty(level_full_path))
    {
        PRINT("Error: couldn't change level to %S\n", level_full_path);
        return;
    }
    
    // Write the new level to local.variables. 
    
    // Clean all level data, i.e., level_arena, zero struct, audio_deinit().
    
    // Load the new level.
}

extern "C" void game_update(Game_Memory *memory, Game_Input *input)
{
    
    Game_State *game    = (Game_State *) memory->permanent_storage;
    Button_State *kb    = input->keyboard_buttons;
    f32 dt              = input->delta_time;
    
    //
    // Iterate over all entities.
    //
    update_point_light_uniforms(game);
    update_entities(game, input, dt);
    
}

extern "C" void game_render(Game_Memory *memory, Game_Input *input)
{
    
    Game_State *game    = (Game_State *) memory->permanent_storage;
    Button_State *kb    = input->keyboard_buttons;
    f32 dt              = input->delta_time;
    Vector3 delta_mouse = input->mouse_ndc - game->old_mouse_ndc;
    game->old_mouse_ndc = input->mouse_ndc;
    
    // Reset the sort index each frame but keep the old entity pointer.
    game->selected_entity.sort_index = MAX_F32;
    
    if(game->use_debug_camera)
    {
        game->active_camera = &game->debug_camera;
    }
    else
    {
        game->active_camera         = &game->game_camera;
        game->debug_camera.position = global_player->position + make_vector3(0.0f, 10.0f, 10.0f);
    }
    
    game->mouse_world = unproject(game->active_camera->position, 1.0f, 
                                  input->mouse_ndc,
                                  world_to_view_matrix,
                                  view_to_proj_matrix);
    
    //
    // Iterate over all entities.
    //
    render_entities(game, input, dt);
    
    //
    // Render the terrain.
    // 
    render_terrain(game, &game->terrain);
    
    //
    // Render the skybox.
    // 
    render_skybox(game, &game->skybox);
    
    
    
#if DEBUG_BUILD
    //
    // Debug camera.
    //
    if(was_pressed(input->mouse_buttons[MouseButton_RIGHT]))
        game->use_debug_camera = !game->use_debug_camera;
    if(game->use_debug_camera)
    {
        Vector3 cam_p = game->debug_camera.position;
        Vector3 cam_f = game->debug_camera.front;
        Vector3 cam_u = game->debug_camera.up;
        Vector3 cam_r = normalize(cross(cam_f, cam_u));
        
        f32 camera_movement_speed = 0.1f;
        if(is_down(kb[Key_D]))
            cam_p +=  camera_movement_speed * cam_r;
        if(is_down(kb[Key_A]))
            cam_p += -camera_movement_speed * cam_r;
        if(is_down(kb[Key_W]))
            cam_p +=  camera_movement_speed * cam_f;
        if(is_down(kb[Key_S]))
            cam_p += -camera_movement_speed * cam_f;
        if(is_down(kb[Key_E]))
            cam_p +=  camera_movement_speed * cam_u;
        if(is_down(kb[Key_Q]))
            cam_p += -camera_movement_speed * cam_u;
        
        if(input->alt_down && is_down(input->mouse_buttons[MouseButton_LEFT]))
        {
            f32 rotation_speed = 1.0f;
            Quaternion q_yaw = make_quaternion_from_axis_and_angle(cam_u, -rotation_speed*delta_mouse.x);
            cam_f = q_yaw*cam_f;
            
            Quaternion q_pitch = make_quaternion_from_axis_and_angle(cam_r,  rotation_speed*delta_mouse.y);
            if(_absolute(dot(cam_u, q_pitch*cam_f)) < 0.98f)
                cam_f = q_pitch*cam_f;
        }
        
        world_to_view_matrix = look_at(cam_p, cam_p + cam_f, cam_u);
        
        game->debug_camera.position = cam_p;
        game->debug_camera.front    = cam_f;
        game->debug_camera.up       = cam_u;
    }
    
    //
    // Level editor.
    //
    Selected_Entity *selected_entity = &game->selected_entity;
    Entity *se_e        = selected_entity->entity;
    
    // Render Bounding_Box on hover.
    Selected_Entity se_hover;
    se_hover.sort_index = MAX_F32;
    se_hover.entity     = game->level_entities + 0;
    for(Entity_Iterator it = iterate_all_entities(game);
        it.entity;
        advance(&it))
    {
        Entity *e = it.entity;
        
        Entity *se_hover_e = select_entity(game, &se_hover, e);
        if(se_hover_e->type != EntityType_INVALID)
        {
            render_bounding_box(game, se_hover_e, &se_hover_e->mesh->bounding_box);
        }
    }
    
    // Select an entity or process it if we already have one.
    if(se_e && (se_e->type != EntityType_INVALID))
    {
        PRINT("se_e pos: %v3\n", se_e->position);
        
        Ray camera_ray;
        camera_ray.o = game->active_camera->position;
        camera_ray.d = normalize(game->mouse_world - camera_ray.o);
        camera_ray.t = MAX_F32;
        
        if(input->del_pressed)
        {
            if(is_set(se_e, EntityFlags_VISIBLE))
            {
                push(selected_entity);
                
                clear_flags(se_e, EntityFlags_VISIBLE);
                
                push(selected_entity);
            }
        }
        
        if(input->ctrl_down && was_pressed(kb[Key_C]))
        {
            if(se_e->type != EntityType_PLAYER)
                add_editor_entity(game, selected_entity, camera_ray);
        }
        if(input->ctrl_down && was_pressed(kb[Key_Z])) 
        {
            if(undo(selected_entity)) undo(selected_entity);
            else                      PRINT("UNDO FAILED!\n");
        }
        if(input->ctrl_down && was_pressed(kb[Key_Y]))
        {
            if(redo(selected_entity)) redo(selected_entity);
            else                      PRINT("REDO FAILED!\n");
        }
        
        if(was_pressed(kb[Key_F]))
        {
            zoom_object(game, se_e);
        }
        
        // Gizmos!
        if(input->ctrl_down && was_pressed(kb[Key_T])) gizmo_mode = GizmoMode_TRANSLATION;
        if(input->ctrl_down && was_pressed(kb[Key_R])) gizmo_mode = GizmoMode_ROTATION;
        
        gizmo_execute(input, camera_ray, selected_entity);
    }
    else if(was_pressed(input->mouse_buttons[MouseButton_LEFT]))
    {
        for(Entity_Iterator it = iterate_all_entities(game);
            it.entity;
            advance(&it))
        {
            Entity *e = it.entity;
            
            select_entity(game, &game->selected_entity, e);
        }
    }
    
    // De-select entity.
    if(was_pressed(input->mouse_buttons[MouseButton_MIDDLE]))
    {
        game->selected_entity.entity = game->level_entities + 0;
        game->selected_entity.current_history_index = 0;
        game->selected_entity.history_record_count  = 0;
    }
    
    // Save level!
    if(input->shift_down && input->fk_pressed[2])
    {
        STRING_TEMPF(destination_full_path, "%s%s", global_data_directory_full_path, "level_data/main.level");
        save_level(game, destination_full_path);
    }
#endif
}
